// ********RoostGPT********
/*
Test generated by RoostGPT for test javaMvnSample using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=addResourceHandlers_ac8819fe1c
ROOST_METHOD_SIG_HASH=addResourceHandlers_ce66a353ba

================================VULNERABILITIES================================
Vulnerability: CWE-22: Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')
Issue: The code allows users to upload files to the server. If not properly sanitized, the user input can lead to a path traversal vulnerability where an attacker can read or write to any file on the system.
Solution: Validate user inputs strictly. Only allow alphanumeric characters in the file name. Don't allow any directory separators or relative paths. Use a library to sanitize the file path before using it.

Vulnerability: CWE-73: External Control of File Name or Path
Issue: The code is using user-provided paths (properties.getUploadDir()) to store uploaded files. This can lead to a number of vulnerabilities such as path traversal, overwriting of critical files, or storage space consumption.
Solution: Do not use user-controlled variables to specify a file path. Instead, use a server-controlled variable for the base directory and append a server-controlled, unique filename to store the uploaded file.

Vulnerability: CWE-494: Download of Code Without Integrity Check
Issue: The code is not checking the integrity of the files before serving them. An attacker can modify the files on the server, which will then be served to the users.
Solution: Implement a mechanism to check the integrity of files before serving them. This can be done by storing and verifying a cryptographic hash of the file.

================================================================================
"""
Scenario 1: Successful addition of resource handlers

Details:
  TestName: testSuccessfulAdditionOfResourceHandlers
  Description: This test is meant to check if the resource handler is successfully added to the registry.
Execution:
  Arrange: Mock the ResourceHandlerRegistry and provide a mock upload directory in the properties.
  Act: Invoke the addResourceHandlers method with the mocked registry.
  Assert: Use JUnit assertions to verify that the resource handler has been added to the registry.
Validation:
  The assertion aims to verify that the resource handler has been added correctly. This is important in the context of application behavior as it ensures that the resources are served correctly.

Scenario 2: Check cache period setting

Details:
  TestName: testCachePeriodSetting
  Description: This test is meant to check if the cache period is set correctly for the added resource handler.
Execution:
  Arrange: Mock the ResourceHandlerRegistry and provide a mock upload directory in the properties.
  Act: Invoke the addResourceHandlers method with the mocked registry.
  Assert: Use JUnit assertions to verify that the cache period has been set to 3600.
Validation:
  The assertion aims to verify that the cache period is set correctly. This is important for performance purposes, as it controls how long the resources are cached.

Scenario 3: Check resource chain setting

Details:
  TestName: testResourceChainSetting
  Description: This test is meant to check if the resource chain is set correctly for the added resource handler.
Execution:
  Arrange: Mock the ResourceHandlerRegistry and provide a mock upload directory in the properties.
  Act: Invoke the addResourceHandlers method with the mocked registry.
  Assert: Use JUnit assertions to verify that the resource chain is set to true.
Validation:
  The assertion aims to verify that the resource chain is set correctly. This is important for the correct resolution of resources.

Scenario 4: Check path resource resolver addition

Details:
  TestName: testPathResourceResolverAddition
  Description: This test is meant to check if a PathResourceResolver is added to the resource chain of the added resource handler.
Execution:
  Arrange: Mock the ResourceHandlerRegistry and provide a mock upload directory in the properties.
  Act: Invoke the addResourceHandlers method with the mocked registry.
  Assert: Use JUnit assertions to verify that a PathResourceResolver has been added to the resource chain.
Validation:
  The assertion aims to verify that a PathResourceResolver has been added. This is important for the correct resolution of resources.
"""
*/

// ********RoostGPT********
package com.learnk8s.knote;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mockito;
import org.springframework.test.context.junit4.SpringRunner;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.resource.PathResourceResolver;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@RunWith(SpringRunner.class)
public class KnoteConfigAddResourceHandlersTest {

	private KnoteProperties properties = Mockito.mock(KnoteProperties.class);

	@Test
	public void testSuccessfulAdditionOfResourceHandlers() {
		ResourceHandlerRegistry registry = Mockito.mock(ResourceHandlerRegistry.class);
		Mockito.when(properties.getUploadDir()).thenReturn("mockDir");

		KnoteConfig config = new KnoteConfig();
		config.addResourceHandlers(registry);

		Mockito.verify(registry, Mockito.times(1)).addResourceHandler("/uploads/**");
		Mockito.verify(registry, Mockito.times(1)).addResourceLocations("file:mockDir");
	}

	@Test
	public void testCachePeriodSetting() {
		ResourceHandlerRegistry registry = Mockito.mock(ResourceHandlerRegistry.class);
		Mockito.when(properties.getUploadDir()).thenReturn("mockDir");

		KnoteConfig config = new KnoteConfig();
		config.addResourceHandlers(registry);

		Mockito.verify(registry, Mockito.times(1)).setCachePeriod(3600);
	}

	@Test
	public void testResourceChainSetting() {
		ResourceHandlerRegistry registry = Mockito.mock(ResourceHandlerRegistry.class);
		Mockito.when(properties.getUploadDir()).thenReturn("mockDir");

		KnoteConfig config = new KnoteConfig();
		config.addResourceHandlers(registry);

		Mockito.verify(registry, Mockito.times(1)).resourceChain(true);
	}

	@Test
	public void testPathResourceResolverAddition() {
		ResourceHandlerRegistry registry = Mockito.mock(ResourceHandlerRegistry.class);
		Mockito.when(properties.getUploadDir()).thenReturn("mockDir");

		KnoteConfig config = new KnoteConfig();
		config.addResourceHandlers(registry);

		Mockito.verify(registry, Mockito.times(1)).addResolver(Mockito.any(PathResourceResolver.class));
	}

}
